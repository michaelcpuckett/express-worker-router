# Swarf

**Swarf** stands for **Service Worker App Router Framework**.

It is a package that provides an API similar to Next.js's App Router, but
designed for a Service Worker context.

## Philosophy

Swarf is an opinionated framework that requires using TypeScript and TSX.

Under the hood, this package uses
[@express-worker/app](https://github.com/michaelcpuckett/express-worker) to
serve the routes. If this framework is too opinionated for your needs, consider
using @express-worker/app directly. For a more fully-featured Service Worker
framework, look to Google's
[Workbox](https://developer.chrome.com/docs/workbox).

## Features

### App Router

Similar to [Next.js](https://nextjs.org/), routes are defined as a directory
structure under `src/app`.

### React SSR

The initial page HTML is rendered by React-DOM/Server which then gets hydrated
by React-DOM/Client.

### Static File Handling

Static files in the `src/app` directory are cached and served by the service
worker.

## Installation

After running `npm install swarf --save`, create a `src\app` folder. The folders
inside are used to define the routes. Folders can be nested. The `page.tsx` file
inside each folder is the component that renders the body of the page.

Base the directory structure on the
[starter kit](https://github.com/michaelcpuckett/sw-app-router-starter).

## Usage

To add a new page:

1. Create a new folder in the `src/app` directory and create a `page.tsx` file
   inside it.

   Dynamic routes are defined by using square brackets in the folder name. For
   example, if you want to create a dynamic route for user profiles, you can
   create a folder with a path of `src/app/profiles/[id]`.

   Each route folder should have a `page.tsx` inside. (Unlike Next.js, there is
   no `layout.tsx` file.)

2. Define the React component for the page as the `default` export.

3. Define and export `getStaticProps` and `metadata`. (See below.)

4. Run `npm run build` to regenerate the routes.

See the
[Next.js documentation](https://nextjs.org/docs/app/getting-started/layouts-and-pages#creating-a-page)
but be mindful of differences, such as the lack of `layout.tsx`.

### Static Props

`getStaticProps` is a function used to fetch data at render time. It allows you
to fetch data from an API or database and pass it as props to the page
component. The path params are passed to this function. You can define
`getStaticProps` as follows:

```ts
export const getStaticProps: GetStaticProps = async function ({
  params: { id },
}) {
  const data = await fetchData({ id });

  return {
    props: {
      data,
    },
  };
};
```

### Metadata

`metadata` is an object that contains information about the page, such as the
title and description. You can define `metadata` as follows:

```ts
export const metadata: Metadata = {
  title: 'Page Title',
  description: 'Page description',
};
```

If you need to access the route params, you can export a function instead:

```ts
export const metadata: GetMetadata = ({ params: { id } }) => ({
  title: 'Note ' + id,
});
```

### Page Component

The `default` export should be the Page component. It will receive the props
defined in `getStaticProps`. It will be wrapped in the `PageShell`.

```tsx
export default function HomePage({ data }: { data: Data }) {
  return <main>{data.foo}</main>;
}
```

## Development

Run `swarf dev` during development.

For easiest debugging, in the Web Inspector, under the Application tab, under
Service Workers, select the checkbox for "Update on reload".

## Production Builds

Run `swarf build` to generate a production build/

The built-in strategy for invalidating the old cache and serving the updated
content is through incrementing the version in `router.config.json`.

Publish the `public` directory to a static file hosting service. A 404.html file
should be served as a catch-all route.

## Benefits

### Fast Page Rendering

Routes can pre-cache or inline key assets. This allows navigation between pages
to be nearly instantaneous.

### Simplified Hosting

The server only needs to be able to serve the initial static assets. This
project uses Firebase Static Hosting.

### Offline-Ready

When a user navigates to a route while offline, the service worker can serve a
previously cached response or generate a new one based on stored data.

## Drawbacks

### No Search Engine Indexing

Pages generated by a service worker aren't indexed by search engines. You may
need alternative strategies for SEO, such as generating static HTML snapshots or
using a separate build process to create server-rendered pages.

## License

This project is licensed under the MIT License.
